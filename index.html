<!doctype html>
<meta charset="utf-8">
<link rel="stylesheet" href="https://unpkg.com/uplot@1.6.30/dist/uPlot.min.css">
<style>
  html,body { margin:0; padding:0; background:#fff; }
  #c { width: 180px; height: 72px; display:block; line-height:0; }
</style>
<div id="c"></div>
<script src="https://unpkg.com/uplot@1.6.30/dist/uPlot.iife.min.js"></script>
<script>
(async () => {
  const lat = 53.2220301, lon = 18.0544024; // Żołędowo coords [web:16]

  // Open‑Meteo hourly: pressure_msl (hPa) + precipitation (mm), last 7d + next 7d, local time. [web:16]
  const params = new URLSearchParams({
    latitude: String(lat),
    longitude: String(lon),
    hourly: "pressure_msl,precipitation",
    past_days: "7",
    forecast_days: "7",
    timezone: "auto"
  });
  const url = "https://api.open-meteo.com/v1/forecast?" + params.toString(); // No API key required. [web:16]

  const res = await fetch(url);
  if (!res.ok) { document.getElementById("c").textContent = "Fetch error"; return; }
  const j = await res.json();

  const times = j?.hourly?.time || [];
  const pVals = j?.hourly?.pressure_msl || [];
  const rVals = j?.hourly?.precipitation || [];
  if (!times.length || !pVals.length || !rVals.length) { document.getElementById("c").textContent = "No data"; return; }

  const x  = times.map(t => new Date(t).getTime());                 // uPlot time axis uses epoch ms. [web:83]
  const yP = pVals.map(v => v == null ? null : Number(v));          // hPa numeric series. [web:16]
  const yR = rVals.map(v => v == null ? null : Number(v));          // mm/h numeric series. [web:16]

  // Constrain pressure to top 1/3 of its dynamic range. [web:164][web:83]
  const pMin = Math.min(...yP.filter(v => v != null));
  const pMax = Math.max(...yP.filter(v => v != null));
  const pBottom = pMin + (pMax - pMin) * (2/3);
  const pTop = pMax;

  // Right axis (precip) range: 0..max(>=1) for visibility. [web:83]
  const rMin = 0;
  const rMax = Math.max(1, ...(yR.filter(v => v != null)));

  // Vertical "now" marker. [web:83]
  const now = Date.now();
  function nowLine(nowTs){
    return { hooks:{ draw:(u)=>{
      const xPos = u.valToPos(nowTs,"x",true);
      if (xPos < u.bbox.left || xPos > u.bbox.left + u.bbox.width) return;
      const ctx=u.ctx; ctx.save(); ctx.strokeStyle="#e74c3c"; ctx.lineWidth=1; ctx.setLineDash([3,3]);
      ctx.beginPath(); ctx.moveTo(xPos,u.bbox.top); ctx.lineTo(xPos,u.bbox.top+u.bbox.height); ctx.stroke(); ctx.restore();
    }}};
  }

  // Red horizontal reference lines at 1000 and 1026 hPa on pressure scale. [web:83]
  function refLinesPlugin(levels, color = "#d33") {
    return {
      hooks: {
        draw: (u) => {
          const { top, height, left, width } = u.bbox;
          const ctx = u.ctx;
          ctx.save();
          ctx.strokeStyle = color;
          ctx.lineWidth = 1;
          ctx.setLineDash([4, 3]);
          for (const v of levels) {
            const y = u.valToPos(v, "p", true);
            if (y < top || y > top + height) continue;
            ctx.beginPath();
            ctx.moveTo(left, y);
            ctx.lineTo(left + width, y);
            ctx.stroke();
          }
          ctx.restore();
        }
      }
    };
  }

  const container = document.getElementById("c");
  const w = container.clientWidth || 180, h = container.clientHeight || 72;

  // Build chart with tiny gutters so the plot fills the canvas. [web:83]
  const u = new uPlot({
    width: w,
    height: h,
    tzDate: ts => new Date(ts),                                      // times localized by timezone=auto. [web:16]
    padding: [2, 2, 2, 2],                                           // minimal frame. [web:83]
    scales: {
      x: { time: true },                                             // time x-axis. [web:83]
      p: { range: [pBottom, pTop] },                                 // pressure: top third only. [web:164]
      r: { range: [rMin, rMax] }                                     // precip full range. [web:83]
    },
    axes: [
      // X axis: extremely compact values; only ~3 ticks to save vertical space.
      {
        show: true,
        size: 12,
        space: 40,                                                   // min px between labels. [web:85]
        splits: (u, vals) => {
          const target = 3;
          const step = Math.ceil(vals.length / target) || 1;
          const out = [];
          for (let i = 0; i < vals.length; i += step) out.push(vals[i]);
          return out;
        },                                                            // sparse ticks to avoid crowding. [web:79]
        values: (u, vals) => vals.map(v => {
          const d = new Date(v);
          return `${d.getDate()}-${String(d.getHours()).padStart(2,"0")}`; // "DD-HH" compact. [web:89][web:83]
        }),
        ticks: { show: true },
        grid: { show: false },
        font: "9px system-ui",
        gap: 2
      },
      // Left Y axis (pressure): hide labels and ticks to reclaim space. [web:83]
      {
        show: true,
        scale: "p",
        size: 2,
        values: () => [],
        ticks: { show: false },
        grid: { show: false }
      },
      // Right Y axis (precip): hide labels and ticks. [web:83]
      {
        show: true,
        scale: "r",
        side: 1,
        size: 2,
        values: () => [],
        ticks: { show: false },
        grid: { show: false }
      }
    ],
    series: [
      {},                                                            // x series placeholder. [web:83]
      { label:"Pressure", scale:"p", stroke:"#2b6cb0", width:1, fill:"rgba(43,108,176,0.10)", points:{ show:false } }, // left axis. [web:83]
      { label:"Precip",  scale:"r", stroke:"#1f9d55", width:1, points:{ show:false } }                                   // right axis. [web:83]
    ],
    plugins: [
      nowLine(now),                                                  // vertical now line. [web:83]
      refLinesPlugin([1000, 1026])                                   // 1000/1026 hPa horizontal lines. [web:83]
    ]
  }, [x, yP, yR], container);

  // Tiny responsiveness within fixed box. [web:83]
  const ro = new ResizeObserver(entries => {
    for (const e of entries) {
      const cw = e.contentRect.width, ch = e.contentRect.height;
      u.setSize({ width: Math.max(140, cw), height: Math.max(60, ch) });
    }
  });
  ro.observe(container);
})();
</script>
