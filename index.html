<!doctype html>
<meta charset="utf-8">
<link rel="stylesheet" href="https://unpkg.com/uplot@1.6.30/dist/uPlot.min.css">
<style>
  html,body { margin:0; padding:0; background:#fff; }
  #c { width: 180px; height: 72px; } /* ~20% of 900x360 */
</style>
<div id="c"></div>
<script src="https://unpkg.com/uplot@1.6.30/dist/uPlot.iife.min.js"></script>
<script>
(async () => {
  const lat = 53.2220301, lon = 18.0544024; // Żołędowo area

  // Open‑Meteo: hourly mean sea-level pressure, past 7d + next 7d, local timezone [web:16]
  const params = new URLSearchParams({
    latitude: String(lat),
    longitude: String(lon),
    hourly: "pressure_msl",
    past_days: "7",
    forecast_days: "7",
    timezone: "auto"
  });
  const url = "https://api.open-meteo.com/v1/forecast?" + params.toString(); // No key needed. [web:16]

  const res = await fetch(url);
  if (!res.ok) { document.getElementById("c").textContent = "Fetch error"; return; }
  const j = await res.json();

  const times = j?.hourly?.time || [];
  const vals  = j?.hourly?.pressure_msl || [];
  if (!times.length || !vals.length) { document.getElementById("c").textContent = "No data"; return; }

  const x = times.map(t => new Date(t).getTime());     // epoch ms for uPlot time axis. [web:83]
  const y = vals.map(v => v == null ? null : Number(v));

  // Optional “now” marker
  const now = Date.now();
  function nowLine(nowTs){
    return { hooks:{ draw:(u)=>{
      const xPos = u.valToPos(nowTs,"x",true);
      if (xPos < u.bbox.left || xPos > u.bbox.left + u.bbox.width) return;
      const ctx=u.ctx; ctx.save(); ctx.strokeStyle="#e74c3c"; ctx.lineWidth=1; ctx.setLineDash([3,3]);
      ctx.beginPath(); ctx.moveTo(xPos,u.bbox.top); ctx.lineTo(xPos,u.bbox.top+u.bbox.height); ctx.stroke(); ctx.restore();
    }}};
  }

  const container = document.getElementById("c");
  const w = container.clientWidth || 180, h = container.clientHeight || 72;

  // Build chart with rotated/sparse x labels, extra spacing & padding to avoid clipping. [web:83][web:79][web:85][web:88]
  const u = new uPlot({
    width: w,
    height: h,
    tzDate: ts => new Date(ts),                      // timezone=auto gives local times. [web:16]
    scales: { x:{ time:true }, y:{ auto:true } },    // time x-axis and auto y-scale. [web:83]
    padding: [6, 4, 6, 6],                           // top,right,bottom,left padding to keep edge labels visible. [web:83]
    axes: [
      {
        show: true,
        size: 26,                                    // a bit taller to fit rotated labels. [web:79]
        space: 32,                                   // min px between labels to reduce crowding. [web:85]
        splits: (u, vals) => {                       // downsample ticks to ~6 visible across tiny width. [web:79]
          const target = 6;
          const step = Math.ceil(vals.length / target) || 1;
          const out = [];
          for (let i = 0; i < vals.length; i += step) out.push(vals[i]);
          return out;
        },
        values: (u, vals) => vals.map(v => {
          const d = new Date(v);
          return `${d.getDate()}\n${String(d.getHours()).padStart(2,"0")}h`; // "DD\nHHh" two-line compact. [web:89][web:83]
        }),
        ticks: { show: true },
        grid: { show: false },
        font: "10px system-ui",
        gap: 6,
        rotate: -45                                  // rotate ~45° to gain horizontal room. [web:88][web:96]
      },
      {
        show: true,
        size: 34,                                    // more room to avoid left-side clipping of 4-digit hPa. [web:79]
        values: (u, vals) => vals.map(v => v.toFixed(0)),
        grid: { show: true, stroke: "rgba(0,0,0,0.06)" }
